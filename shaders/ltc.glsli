//
// Copyright (C) YuqiaoZhang(HanetakaChou)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef _LTC_GLSLI_
#define _LTC_GLSLI_ 1

#include "math_consts.glsli"
#include "brdf.glsli"
#include "preintegrated_hdr.glsli"

// This function is provided by the user
highp mat3x3 ltc_matrix_tr(highp float roughness, highp float NdotV);

// [in] culling_range: a finite range to support light culling 
// [in] P: The surface position in world space.
// [in] vertices_world_space: The vertices of the quad in world space. The facing of the quad is determined by the winding order of the vertices.
highp float evaluate_ltc_light_attenuation(highp float culling_range, highp vec3 P, highp vec3 vertices_world_space[4]);

// [in] P: The surface position in world space.
// [in] N: The surface normal in world space.
// [in] V: The outgoing direction in world space.
// [in] vertices_world_space: The vertices of the quad in world space. The facing of the quad is determined by the winding order of the vertices.
highp vec3 evaluate_brdf_ltc(highp vec3 diffuse_color, highp float roughness, highp vec3 specular_color, highp vec3 P, highp vec3 N, highp vec3 V, highp vec3 vertices_world_space[4]);

// [in] vertices_tangent_space: The vertices of the quad in tangent space. The facing of the quad is determined by the winding order of the vertices.
highp vec3 diffuse_lambert_ltc(highp vec3 diffuse_color, highp vec3 vertices_tangent_space[4]);

// [in] vertices_tangent_space: The vertices of the quad in tangent space. The facing of the quad is determined by the winding order of the vertices.
highp vec3 specular_tr_ltc(highp vec3 specular_color, highp float roughness, highp float ndotv, highp vec3 vertices_tangent_space[4]);

// [in] vertices_tangent_space: The vertices of the quad in tangent space. The facing of the quad is determined by the winding order of the vertices.
highp float evaluate_form_factor_over_quad(highp vec3 vertices_tangent_space[4]);

// [in] vertices_tangent_space: The vertices of the quad in tangent space. The facing of the quad is determined by the winding order of the vertices.
highp vec3 evaluate_vector_form_factor_over_quad(highp vec3 vertices_tangent_space[4]);

// [in] v1: The first normalized vertex which is projected onto the sphere. The facing of the quad is determined by the winding order of the vertices.
// [in] v2: The second normalized vertex which is projected onto the sphere. The facing of the quad is determined by the winding order of the vertices.
highp vec3 evaluate_vector_form_factor_over_quad_edge(highp vec3 v1, highp vec3 v2);

// [in] cos_elevation_angle : implies the direction of the vector irrandiance of the sphere proxy
// [in] sin_angular_extent : implies the length of the vector irrandiance of the sphere proxy
highp float evaluate_form_factor_over_sphere(highp float cos_elevation_angle, highp float sin_angular_extent);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//    IMPLEMENTATION
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
highp float evaluate_ltc_light_attenuation(highp float culling_range, highp vec3 P, highp vec3 vertices_world_space[4])
{
    highp vec3 v0_to_v1 = vertices_world_space[1] - vertices_world_space[0];
    highp vec3 v0_to_v3 = vertices_world_space[3] - vertices_world_space[0];
    highp vec3 normal_back_face = normalize(cross(v0_to_v1, v0_to_v3));
    highp vec3 L = vertices_world_space[0].xyz - P;
    highp float z = dot(L, normal_back_face);

    [[dont_flatten]] 
    if (z > 0.0)
    {
        highp float x;
        highp float y;
        {
            // [FetchDiffuseFilteredTexture](http://blog.selfshadow.com/publications/ltc/ltc_demo.zip)
            highp vec3 v0_to_p_projected = normal_back_face * z - L;

            // v0_to_p_projected = u * v0_to_v1 + v * v0_to_v3
            // ⇒
            // v0_to_p_projected_dot_v0_to_v1 =  u * v0_to_v1_2 + v * v0_to_v3_dot_v0_to_v1
            // v0_to_p_projected_dot_v0_to_v3 =  u * v0_to_v1_dot_v0_to_v3 + v * v0_to_v3_2
            // ⇒
            // u = (v0_to_p_projected_dot_v0_to_v1 * v0_to_v3_2 - v0_to_p_projected_dot_v0_to_v3 * v0_to_v3_dot_v0_to_v1) / (v0_to_v1_2 * v0_to_v3_2 - v0_to_v1_dot_v0_to_v3 * v0_to_v3_dot_v0_to_v1)
            // v = (v0_to_p_projected_dot_v0_to_v3 * v0_to_v1_2 - v0_to_p_projected_dot_v0_to_v1 * v0_to_v1_dot_v0_to_v3) / (v0_to_v1_2 * v0_to_v3_2 - v0_to_v1_dot_v0_to_v3 * v0_to_v3_dot_v0_to_v1)
            highp float v0_to_p_projected_dot_v0_to_v1 = dot(v0_to_p_projected, v0_to_v1);
            highp float v0_to_p_projected_dot_v0_to_v3 = dot(v0_to_p_projected, v0_to_v3);
            highp float v0_to_v1_2 = dot(v0_to_v1, v0_to_v1);
            highp float v0_to_v3_2 = dot(v0_to_v3, v0_to_v3);
            highp float v0_to_v1_dot_v0_to_v3 = dot(v0_to_v1, v0_to_v3);
            highp float v0_to_v3_dot_v0_to_v1 = v0_to_v1_dot_v0_to_v3;
            highp float determinant = v0_to_v1_2 * v0_to_v3_2 - v0_to_v1_dot_v0_to_v3 * v0_to_v3_dot_v0_to_v1;
            highp float u = (v0_to_p_projected_dot_v0_to_v1 * v0_to_v3_2 - v0_to_p_projected_dot_v0_to_v3 * v0_to_v3_dot_v0_to_v1) / determinant;
            highp float v = (v0_to_p_projected_dot_v0_to_v3 * v0_to_v1_2 - v0_to_p_projected_dot_v0_to_v1 * v0_to_v1_dot_v0_to_v3) / determinant;
            x = u * length(v0_to_v1);
            y = v * length(v0_to_v3);
        }

        highp float factor_2;
        {
            // [EllipsoidalDistanceAttenuation](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl#L1591)
            // [BoxDistanceAttenuation](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl#L1597)
            highp float normalized_x = x / (culling_range + 0.5 * length(v0_to_v1));
            highp float normalized_y = y / (culling_range + 0.5 * length(v0_to_v3));
            highp float normalized_z = z / culling_range;
            factor_2 = normalized_x * normalized_x + normalized_y * normalized_y + normalized_z * normalized_z;
        }

        highp float windowing_function;
        {
            // [Sebastian Lagarde, Charles Rousiers. "Moving Frostbite to PBR." SIGGRAPH 2014.](https://www.ea.com/frostbite/news/moving-frostbite-to-pb)
            // factor = "x (distance) / light_radius"
            // highp float factor_2 = factor * factor;
            highp float factor_4 = factor_2 * factor_2;
            highp float distance_factor = clamp(1.0 - factor_4, 0.0, 1.0);
            highp float smooth_distance_factor = distance_factor * distance_factor;
            windowing_function = smooth_distance_factor;
        }

        return windowing_function;
    }
    else
    {
        // TODO: some parts of the quad may still in the upper hemisphere
        return 0.0;
    }
}

highp vec3 evaluate_brdf_ltc(highp vec3 diffuse_color, highp float roughness, highp vec3 specular_color, highp vec3 P, highp vec3 N, highp vec3 V, highp vec3 vertices_world_space[4])
{
    highp vec3 radiance = vec3(0.0, 0.0, 0.0);

    // Transform the vertices to the tangent space of the current shading position.
    highp vec3 vertices_tangent_space[4];
    {
        // The LUTs are precomputed by assuming that the outgoing direction V is in the XOZ plane, since the TR BRDF is isotropic.
        highp vec3 T1 = normalize(V - N * dot(V, N));
        highp vec3 T2 = cross(N, T1);

        highp mat4x4 world_to_tangent_transform =
            mat4x4(
                vec4(T1.x, T2.x, N.x, 0.0),                     // col 0
                vec4(T1.y, T2.y, N.y, 0.0),                     // col 1
                vec4(T1.z, T2.z, N.z, 0.0),                     // col 2
                vec4(dot(T1, -P), dot(T2, -P), dot(N, -P), 1.0) // col 3
            );

        vertices_tangent_space[0] = (world_to_tangent_transform * vec4(vertices_world_space[0], 1.0)).xyz;
        vertices_tangent_space[1] = (world_to_tangent_transform * vec4(vertices_world_space[1], 1.0)).xyz;
        vertices_tangent_space[2] = (world_to_tangent_transform * vec4(vertices_world_space[2], 1.0)).xyz;
        vertices_tangent_space[3] = (world_to_tangent_transform * vec4(vertices_world_space[3], 1.0)).xyz;
    }

    highp float non_clamped_NdotV = dot(N, V);
    // UE: [DefaultLitBxDF]https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/ShadingModels.ush#L218
    // U3D: [ClampNdotV](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl#L349)
    highp float NdotV = clamp(non_clamped_NdotV, 0.0001, 1.0);

    radiance += diffuse_lambert_ltc(diffuse_color, vertices_tangent_space);

    radiance += specular_tr_ltc(specular_color, roughness, NdotV, vertices_tangent_space);

    return radiance;
}

highp vec3 diffuse_lambert_ltc(highp vec3 diffuse_color, highp vec3 vertices_tangent_space[4])
{
    highp float form_factor_over_quad = evaluate_form_factor_over_quad(vertices_tangent_space);

    // The terms irradiance and form factor may be interchangeably used. But technically, the irradiance should NOT be divided by π.
    highp float irradiance_over_quad = PI * form_factor_over_quad;

    highp vec3 radiance = diffuse_lambert(diffuse_color) * irradiance_over_quad;
    return radiance;
}

highp vec3 specular_tr_ltc(highp vec3 specular_color, highp float roughness, highp float ndotv, highp vec3 vertices_tangent_space[4])
{
    highp mat3x3 linear_transform_inversed = ltc_matrix_tr(roughness, ndotv);

    // [Hill 2016] [Stephen Hill. "LTC Fresnel Approximation." SIGGRAPH 2016.](https://blog.selfshadow.com/publications/s2016-advances/)
    highp vec3 norm = preintegrated_hdr_tr(specular_color, roughness, ndotv);

    // LT "linear transform"
    highp vec3 vertices_tangent_space_linear_transformed[4] = vec3[4](
        linear_transform_inversed * vertices_tangent_space[0],
        linear_transform_inversed * vertices_tangent_space[1],
        linear_transform_inversed * vertices_tangent_space[2],
        linear_transform_inversed * vertices_tangent_space[3]);

    highp float form_factor_over_quad = evaluate_form_factor_over_quad(vertices_tangent_space_linear_transformed);

    highp vec3 radiance = norm * form_factor_over_quad;

    return radiance;
}

highp float evaluate_form_factor_over_quad(highp vec3 vertices_tangent_space[4])
{
    // [Hill 2016] [Stephen Hill, Eric Heitz. "Real-Time Area Lighting: a Journey from Research to Production." SIGGRAPH 2016.](https://blog.selfshadow.com/publications/s2016-advances/)
    // Theory & Implementation / 3. Clip Polygon to upper hemisphere

    // The vector form factor can be calculated even if the quad id NOT horizon-clipped
    highp vec3 vector_form_factor_over_quad = evaluate_vector_form_factor_over_quad(vertices_tangent_space);

    // Introduce the sphere proxy with the same vector form factor
    highp float cos_elevation_angle = normalize(vector_form_factor_over_quad).z;
    highp float sin_angular_extent = sqrt(length(vector_form_factor_over_quad));

    highp float form_factor_over_sphere = evaluate_form_factor_over_sphere(cos_elevation_angle, sin_angular_extent);

    return form_factor_over_sphere;
}

highp vec3 evaluate_vector_form_factor_over_quad(highp vec3 vertices_tangent_space[4])
{
    // [Heitz 2017] [Eric Heitz. "Geometric Derivation of the Irradiance of Polygonal Lights." Technical report 2017.](https://hal.archives-ouvertes.fr/hal-01458129)

    highp vec3 vertices_normalized[4] = vec3[4](
        normalize(vertices_tangent_space[0]),
        normalize(vertices_tangent_space[1]),
        normalize(vertices_tangent_space[2]),
        normalize(vertices_tangent_space[3]));

    highp vec3 vector_form_factor_over_quad = vec3(0.0, 0.0, 0.0);
    vector_form_factor_over_quad += evaluate_vector_form_factor_over_quad_edge(vertices_normalized[0], vertices_normalized[1]);
    vector_form_factor_over_quad += evaluate_vector_form_factor_over_quad_edge(vertices_normalized[1], vertices_normalized[2]);
    vector_form_factor_over_quad += evaluate_vector_form_factor_over_quad_edge(vertices_normalized[2], vertices_normalized[3]);
    vector_form_factor_over_quad += evaluate_vector_form_factor_over_quad_edge(vertices_normalized[3], vertices_normalized[0]);

    return vector_form_factor_over_quad;
}

highp vec3 evaluate_vector_form_factor_over_quad_edge(highp vec3 v1, highp vec3 v2)
{
    // [Hill 2016] [Stephen Hill, Eric Heitz. "Real-Time Area Lighting: a Journey from Research to Production." SIGGRAPH 2016.](https://blog.selfshadow.com/publications/s2016-advances/)
    // Theory & Implementation / 4. Compute edge intergrals

    // acos(dot(v1, v2)) * normalized(cross(v1, v2)) * (1 / 2PI)
    // = acos(dot(v1, v2)) * cross(v1, v2)
    // = (acos(dot(v1, v2)) * (1 / sin(acos(dot(v1, v2)))) * (1 / 2PI)) * cross(v1, v2)

    // cubic rational fit
    // theta_sintheta ≈ (acos(dot(v1, v2)) * (1 / sin(acos(dot(v1, v2)))) * (1 / 2PI))

    highp float x = dot(v1, v2);
    highp float y = abs(x);

    // (1 / 2PI) has been multiplied here
    highp float a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;
    highp float b = 3.4175940 + (4.1616724 + y) * y;
    highp float v = a / b;

    highp float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;

    return cross(v1, v2) * theta_sintheta;
}

highp float evaluate_form_factor_over_sphere(highp float cos_omega, highp float sin_sigma)
{
    // [Snyder 1996]. [John Snyder. "Area Light Sources for Real-Time Graphics." Technical Report 1996.](https://www.microsoft.com/en-us/research/publication/area-light-sources-for-real-time-graphics/)

    highp float form_factor_over_sphere;
#if 0
	// UE4: SphereHorizonCosWrap  
	// ω ∈ [0, π/2 - σ]
	if(cos_omega > sin_sigma)
	{
		form_factor_over_sphere = cos_omega * sin_sigma * sin_sigma;
	}
	// ω ∈ [π/2 - σ, π]
	else
	{
		float tmp = (sin_sigma + max(cos_omega, -sin_sigma));

		form_factor_over_sphere = tmp * tmp / (4 * sin_sigma) * sin_sigma * sin_sigma;
	}
#else
    form_factor_over_sphere = sin_sigma * sin_sigma * (sin_sigma * sin_sigma + cos_omega) / (sin_sigma * sin_sigma + 1.0);
#endif

    return form_factor_over_sphere;
}

#define LTC_MATRIX_LUT_TR_INDEX 0

highp mat3x3 ltc_matrix_tr(highp float roughness, highp float NdotV)
{
    // Remap: [0, 1] -> [0.5/size, 1.0 - 0.5/size]
    // U3D: [Remap01ToHalfTexelCoord](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl#L661)
    // UE: [N/A](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/RectLight.ush#L450)
    highp ivec2 lut_texture_size = textureSize(ltc_matrix_lut, 0);
    highp vec2 lut_bias = vec2(0.5, 0.5) / vec2(lut_texture_size.x, lut_texture_size.y);
    highp vec2 lut_scale = vec2(1.0, 1.0) - vec2(1.0, 1.0) / vec2(lut_texture_size.x, lut_texture_size.y);
    highp vec2 lut_uv = lut_bias + lut_scale * vec2(roughness, sqrt(1.0 - NdotV));

    // highp vec4 ltc_matrix_lut_tr = textureLod(ltc_matrix_lut, vec3(lut_uv, LTC_MATRIX_LUT_TR_INDEX), 0.0).rgba;
    highp vec4 ltc_matrix_lut_tr = textureLod(ltc_matrix_lut, lut_uv, 0.0).rgba;

    highp mat3x3 linear_transform_inversed = mat3x3(
        vec3(ltc_matrix_lut_tr.x, 0.0, ltc_matrix_lut_tr.y), // column 0
        vec3(0.0, 1.0, 0.0),                                 // column 1
        vec3(ltc_matrix_lut_tr.z, 0.0, ltc_matrix_lut_tr.w)  // column 2
    );

    return linear_transform_inversed;
}

#endif